# コアコンセプト

## 哲学

Kex は、コードの良し悪しを裁く「裁判官 (Judge)」ではありません。
Kex は、コードの品質判断は AI エージェント自身に委ね、その補佐として必要なガイドラインを的確に提示する「**Librarian (司書)**」として設計されています。

- **動的かつ効率的なコンテキスト**: AI は必要なときに動的にコンテキストを取得するべきですが、そのための労力 (およびコンテキストウィンドウの消費) は最小限に抑えられるべきです。
- **システムプロンプトの浄化**: コーディングガイドラインをプロジェクトのプロンプト (例: `.cursorrules`) にハードコードするべきではありません。それらはリポジトリ (または中央ナレッジベース) で管理され、Kex によってインデックス化されるべきです。
- **構造は厳格に、意味は人間が所有する**: スキーマ (Frontmatter) は強制しますが、内容はあなた次第です。
- **知識の集約**: ドメインに依存しない汎用的な知識を中央に集約し、**Librarian** (Kex) を通じて提供します。これにより、プロジェクトごとのプロンプトにルールを書き写す手間や、ルールを知らない AI を逐一修正するコストを排除します。

## ドキュメントのライフサイクル

Kex はドキュメントの2つの状態を区別します:

- **Draft (下書き)**: 作業中の状態。デフォルトではサーバーから無視されます (設定により変更可能)。検証エラーは警告として扱われます。
- **Adopted (採用)**: 正本。アクティブでありインデックスされます。すべてのバリデーションチェックを通過する必要があります。重大なエラーがあるとサーバーは起動しません。

## アーキテクチャ

Kex はローカルの **MCP (Model Context Protocol) サーバー** として動作します。
単一のバイナリとして実行され、指定されたディレクトリ（ローカルまたはリモート）配下にあるマークダウンファイルをインデックス化します。

これらを JSON-RPC を介して対応する AI クライアント (Claude, VSCode, etc) に提供します。
