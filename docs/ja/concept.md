# コアコンセプト

## 哲学

Kex は、裁判官ではなく「司書 (Librarian)」として設計されています。

- **動的かつ効率的なコンテキスト**: AI は必要なときに動的にコンテキストを取得すべきですが、そのための労力 (およびコンテキストウィンドウの消費) は最小限であるべきです。
- **システムプロンプトの浄化**: コーディングガイドラインをプロジェクトのプロンプト (例: `.cursorrules`) にハードコードするべきではありません。それらはリポジトリ (または中央ナレッジベース) 内に配置され、Kex によってインデックスされるべきです。
- **構造は厳格に、意味は人間が所有する**: スキーマ (Frontmatter) は強制しますが、内容はあなた次第です。
- **知識の集約**: ドメインに依存しない汎用的な知識を中央に集約し、司書 (Kex) を通じてインデックス化します。これにより、プロジェクトごとのプロンプトにルールを書き写す手間や、ルール違反に対して AI を叱るコストを排除します。

## ドキュメントのライフサイクル

Kex はドキュメントの2つの状態を区別します:

- **Draft (下書き)**: 作業中の状態。デフォルトではサーバーから無視されます (設定次第)。エラーは警告として扱われます。
- **Adopted (採用)**: 正本。アクティブでありインデックスされます。すべてのバリデーションチェックを通過する必要があります。エラーがあるとサーバーは起動しません。

## アーキテクチャ

Kex はローカルの **MCP (Model Context Protocol) サーバー** として動作します。
単一のバイナリとして実行され、指定されたディレクトリ（ローカルまたはリモート）配下にあるマークダウンファイルをインデックスします。

これらを JSON-RPC を介して対応する AI クライアント (Claude, VSCode, etc) に提供します。
